{% extends 'docs_layout.twig' %}
{% block content %}
<div class="well">
  <h2>The routing component</h2>
  <p>
    Routing is the process of parsing a url and mapping the resultant tokens to modules, controllers, actions and further parameters. At it's simplest, the {{ hubLink('Proem.Routing.Route.Standard') }}
    object provided by Proem will map a url such as /foo/bar/boo/id/12 to the <em>Foo</em> module, <em>Bar</em> controller (class), <em>Boo</em> action (method) and pass it the number <em>12</em> as the
    parameter <em>id</em>. More complex configurations can be achieved and we can even remap url's to modules, controllers and actions that are not necessarily obvious from looking at the url.
  </p>
</div>
<div class="well">
  <h3>Creating a route.</h3>
  <p>
    The route described in the previous paragraph can be created in Proem very easily using:
  </p>
  <pre class="prettyprint">
    (new \Proem\Routing\Route\Standard([
        'rule' => '/:module/:controller/:action/:params'
    ]))->process('/foo/bar/boo/id/12'); // The url to be processed
  </pre>
  <p>
    The <em>:module</em>, <em>:controller</em>, <em>:action</em> and <em>:params</em> tokens are internally replaced by more complex regular expressions. When <em>process()</em>
    is called the rule is tested against the $url argument. By default, if the entire url matches this series of regular expressions the matching data is stored within a
    {{ hubLink('Proem.Dispatch.Payload') }} object, the <em>populated</em> flag is set on it and this <em>Payload</em>
    is then returned from the <em>Route</em> object's <em>process()</em> method. From the <em>Payload</em> this matching data can be referenced by the corresponding names
    module, controller, action and params. These names have special meaning within the <em>Standard Route</em> and are defined as simple yet very common defaults.
  </p>
  <p>
    For simpler tasks, Routes can be configured to execute a Callback when a match is found instead of creating a returning the Payload object. See <a href="#exec-callback">below:</a>
  </p>
  <p> 
    The tokens <em>:module</em>, <em>:controller</em> and <em>:action</em> all use the same regular expression pattern internally,
    <strong>'[a-zA-Z0-9\_\+\-%]+'</strong>, this pattern is stored within another token called <em>:default</em>. Params is a little
    bit special and it's regular expression is stored internally in a token named :gobble which looks like,
    <strong>'[a-zA-Z0-9\_\+\-%\/]+'</strong>. This will basically gobble everything including backslashes, the route then splits this on the backslashes and returns the
    parts as a key => value pars. So a match like a/b/c/d will return ['a' => 'b', 'c' => 'd'].
  </p>
  <p>
    We could have written the above rule as:
  </p>
  <pre class="prettyprint">
    (new \Proem\Routing\Route\Standard([
        'rule' => '/([a-zA-Z0-9\_\+\-%]+)\/([a-zA-Z0-9\_\+\-%]+)\/([a-zA-Z0-9\_\+\-%]+)\/([a-zA-Z0-9\_\+\-%\/]+)'
    ]));
  </pre>
  <p>
    While this would have found a match, the Router would not have known what indexes to use to store it's results in
    making the rule useless. Hopefully this explains how the <em>:tokens</em> (names starting with a colon) are used to name
    our matches so we can actually reference them.
  </p>
</div>
<div class="well">
  <h3>Defining custom tokens</h3>
  <p>
    While the above defaults are useful, at times you'll want to name your own tokens. This is as simple as placing your
    token in the desired location in the rule, then defining a regular expression for that token to use within the <em>filters</em> array.
  </p>
  <pre class="prettyprint">
    (new \Proem\Routing\Route\Standard([
        'rule'    => '/:module/:controller/:action/:id'
        'filters' => ['id' => '[0-9]+']
    ]));
  </pre>
  <p>
    This would match a url such as /foo/bar/boo/12 and return ['module' => 'foo', 'controller' => 'bar', 'action' => 'boo', 'id' => 12].
  </p>
</div>
<div class="well">
  <h3>Using built in filters</h3>
  <p>
    Because some regular expression patterns are so common, Proem has also provided a simple mechanism for using
    them in filters. The above rule could also have been written using:
  </p>
  <pre class="prettyprint">
    (new \Proem\Routing\Route\Standard([
        'rule'    => '/:module/:controller/:action/:id'
        'filters' => ['id' => ':int']
    ]));
  </pre>
  <p>
    The default filters defined within the <em>Standard Route</em> are:
  </p>
  <pre>
    [
        ':default'  => '[a-zA-Z0-9_\+\-%]+',
        ':gobble'   => '[a-zA-Z0-9_\+\-%\/]+',
        ':int'      => '[0-9]+',
        ':alpha'    => '[a-zA-Z]+',
        ':slug'     => '[a-zA-Z0-9_-]+'
    ]
  </pre>
</div>
<div class="well">
  <h3>Mapping a Route based on the Request method</h3>
  <p>
    It is also possible to have a route only match when the request is of a specific method using the <em>method</em> option:
  </p>
  <pre class="prettyprint">
    (new \Proem\Routing\Route\Standard([
        'rule'    => '/:module/:controller/:action'
        'method'  => 'POST'
    ]));
  </pre>
  <p>
    This means that you can have two different routes match the same url using a different method for each request.
  </p>
</div>
<div class="well">
  <h3>Mapping a url to a specific <em>module</em> / <em>controller</em> or <em>action</em></h3>
  <p>
    Sometimes it is handy to have several different url's all execute the same controller / action. Or sometimes you might just
    want to make a short url for a common task. This can be achieved by forcing the <em>targets</em> of your <em>module</em>, <em>controller</em> or <em>action</em>.
  </p>
  <pre class="prettyprint">
    (new \Proem\Routing\Route\Standard([
        'rule'      => '/user/:name',
        'targets'   => [
            'module'        => 'user',
            'controller'    => 'profiles',
            'action'        => 'view'
        ],
        'filters' => ['name' => ':alpha']
    ]));
  </pre>
  <p>
    This <em>Route</em> would match the url /user/trq and map it to the 'User' module, 'Profiles' controller and the 'View' action.
  </p>
</div>
<div class="well">
  <h3>Using the Static Route</h3>
  <p>
    As of 0.6.0 Proem also ships with a Static Route object. This Route is optimised for speed, but like most things in programming, it achieves this by simplifying
    it's functionality. The Static Route uses simple string matching instead of regular expressions. This means it is ideal for matching hard urls, it cannot however match patterns.
  </p>
  <pre class="prettyprint">
    (new Proem\Routing\Route\StaticRoute([
        'rule'    => '/users',
        'targets' => [
            'module'     => 'profile',
            'controller' => 'users',
            'action'     => 'index'
        ]
    ]));
  </pre>
  <p>
    While it's usage looks similar it cannot make use of tokens at all. This means that static routes like this cannot currently pass any kind of params either.
  </p>
</div>
<div class="well">
  <h3>Configuring multiple <em>Routes</em> using a <em>Router</em></h3>
  <p>
    The above examples demonstrate how to configure simple rules, but web applications these days are complex beasts with multiple
    url's all pointing to multiple resources. How do we handle all this in a simple uniformed manner? Easy, this is where the
    {{ hubLink('Proem.Routing.Router') }} comes into play. The <em>Router</em> is basically responsible for storing a series of <em>Routes</em>
    and managing the execution of there <em>process()</em> method's against the supplied url.
  </p>
  <p>
    This allows us to chain together and build up more complex and flexible Routing rules.
  </p>
  <p>
    The process is actually quite simple, you instantiate a <em>Router</em> passing it a <em>Request</em> object, then attach your <em>Routes</em> onto the <em>Router</em> in the order you wish them
    to be processed (and yes, the order does matter) giving each <em>Route</em> a name. You then call the <em>route()</em> method which loops through all the <em>Routes</em>
    calling <em>process()</em> on each <em>Route</em>. When a match is found two things can happen.
    <ul>
      <li>
        If the <em>matched Route</em> has a Callback attached to it, it is executed and it's returned value returned.
      </li>
      <li>
        Otherwise, the <em>matched Route's</em> Payload data is returned.
      </li>
    </ul>
    More details about what these two different processes can be used for is documented further below in <em>The Route Payload</em> and <em>Configuring Routes to execute a Callback</em>.
  </p>
  <p>
    This entire configuration looks like:
  </p>
  <pre class="prettyprint">
    $router = new \Proem\Routing\Router\Standard($request);
    $payload = $router
        ->attach(
            'home-page',
            new \Proem\Routing\Route\Standard([
                'rule'      => '/',
                'targets'   => ['controller' => 'home']
            ])
        )->attach(
            'login',
            new \Proem\Routing\Route\Standard([
                'rule'      => '/login',
                'targets'   => ['controller' => 'auth', 'action' => 'login']
            ])
        )->attach(
            'logout',
            new \Proem\Routing\Route\Standard([
                'rule'      => '/logout',
                'targets'   => ['controller' => 'auth', 'action' => 'logout']
            ])
        )->route();
  </pre>
</div>
<div class="well">
    <h3>The Route Payload</h3>
    <p>
        I have spoken a little about this <em>Route Payload</em> but what exactly is it? Really, it's nothing more than a simple container containing information about what was matched within a
        <em>Route</em>. It has a simple <em>populated</em> flag that is set to true when the <em>Route</em> has matched, it then stores the <em>Routes</em>'s tokens and there processed values.
    </p>
    <p>
        For example, given the code above, if $request was /login, the Payload would have the parameters <em>controller</em> and <em>action</em> set with the values <em>auth</em> and <em>login</em>
        respectfully.
    </p>
    <p>
        This data is of special interest to the Dispatch component, which is actually the component that calls the Router's <em>route()</em> method during the Bootstrap process. See the
        Dispatch docs for more details.
    </p>
</div>
<div class="well">
  {{ anchor('exec-callback') }}
  <h3>Configuring Routes to execute a Callback</h3>
  <p>
    While having a Route match a url, create a Payload and then eventually have that Payload Dispatched off to execute userland code within modules and controllers is great, sometimes
    we don't need all that overhead. For this reason, since version 0.5.0 Proem has supported attaching a Callback to a Route object.
  </p>
  <pre class="prettyprint">
    (new \Proem\Routing\Route\Standard([
        'rule'      => '/user/:name',
        'callback'   => function($request) {
            echo 'Hello ' . $request->get->name;
        }
    ]));
  </pre>
  <p>
    When this Route is matched the Payload is set as it would normally be, however, instead of the <em>Router</em> sending this <em>Payload</em> off to the <em>Dispatcher</em> the <em>Router</em> itself
    will execute the Callback passing it the current <em>Request</em> object.
  </p>
  <p>
    The idea of using simple Callbacks can be especially useful within small applications and single page apps. You can then make use of Proem's Router without needing to go through the entire frameworks
    bootstrap process.
  </p>
  <p>
    As an example, here is a simple one page app that displays "Hello World!" by default, or, if you go to /hello/somename it will display "Hello Somename!".
  </p>
  <pre class="prettyprint">
    (new \Proem\Routing\Router\Standard(new \Proem\IO\Request\Http\Standard))->attach(
        'default',
        new \Proem\Routing\Route\Standard([
            'rule'      => '/',
            'callback'  => function($request) {
                echo 'Hello World!';
            }
        ])
    )->attach(
        'sayname',
        new \Proem\Routing\Route\Standard([
            'rule'      => '/hello/:name',
            'callback'  => function($request) {
                echo 'Hello ' . $request->get->get('name') . '!';
            }
        ])
    )->route();
  </pre>
  <div class="alert alert-info">
    <p>
        Note that there are currently no means of accessing any other objects from within these Callbacks. There are however plans to at very least pass the <em>Response</em> object if it is available.
    </p>
  </div>
</div>
{{ disqus('/docs/dev/route-component') }}
{% endblock %}
